#include "searchthread.h"
#include "utility.h"

#include <filesystem>
#include <iostream>
#include <fstream>

void SearchThread::run() {

    search();
}

void SearchThread::search() {

    float fileSearchedCount = 0.0;
    float numberFiles = 0;
    std::vector<std::string> validInputFiles;

    gOutput->clear();
    results->reset();

    emit percentageUpdated(0);

    for (std::string s : inputFiles) {

        if (videoTitleContainsTarget(s, termInTitle) || termInTitle == "") {

            validInputFiles.push_back(s);
            numberFiles++;
        }
    }

    for (std::string s : validInputFiles) {

        int progress = (fileSearchedCount / numberFiles) * 100;

        emit percentageUpdated(progress);

        if (videoTitleContainsTarget(s, termInTitle) || termInTitle == "") {

            parseFile(s, toFind);
        }

        fileSearchedCount++;
    }

    results->listAllResults(gOutput);
    emit percentageUpdated(99);
    emit resultReady(*gOutput);
    gOutput->clear();
}

void SearchThread::parseFile(std::string file, std::string target) {

    std::string line;
    std::ifstream infile(file);
    std::string time;
    QVector<std::string> passage;
    QVector<videoMatch> matches;
    bool found = false;
    int foundCount = 0;

    // must read file differently if a subtitle contains a double space
    // this indicates an autogenerated file where all the subtitle
    // text is under a single timestamp
    bool isAutoGenerated = false;
    bool autoGeneratedParagraphProcessed = false;
    int autoGeneratedSubtitleIndex = -1;
    int timestampCount = 0;
    std::vector<std::string> result;
    std::string token = "  ";
    std::string autoGeneratedParagraph;
    std::vector<std::string> splitAutoGeneratedParagraph;
    int duration = 0;

    while (std::getline(infile, line)) {

        std::istringstream iss(line);

        line = removeTags(line);

        // parse the line, it can be time or the text (or blank line)
        if (isTime(line)) {

            time = line;
            duration = getDifferenceTimestamps(time);

            if (isAutoGenerated == true
                    && autoGeneratedSubtitleIndex < result.size()
                    && duration > 10) {

                found = containsTarget(result[autoGeneratedSubtitleIndex], target);

                // prevent duplicate the passage for the first subtitle matched
                // for searching autogenerated subtitles
                if (autoGeneratedSubtitleIndex > 0) {

                    passage.push_back(result[autoGeneratedSubtitleIndex]);
                }

                autoGeneratedSubtitleIndex++;
            }

            timestampCount++;

            // if found target, print the time and the passage
            if (found && duration > 10) {

                // create new match item
                videoMatch match(time, passage);
                matches.push_back(match);
                foundCount++;
            }

            found = false;
            passage.clear();
        }
        else if (!isAutoGenerated) {

            found = containsTarget(line, target);

            // a double space in the subtitles indicates a paragraph
            // with auto generated subtitles
            if (containsTarget(line, "  ") && autoGeneratedParagraphProcessed == false) {

                isAutoGenerated = true;
                autoGeneratedParagraph = line;

                // split paragraph to get the subtitles
                while (line.size()) {

                    int index = line.find(token);

                    if (index != std::string::npos) {

                        result.push_back(line.substr(0, index));
                        line = line.substr(index+token.size());

                        if (line.size() == 0) {

                            result.push_back(line);
                        }
                    }
                    else {

                        result.push_back(line);
                        line = "";
                    }
                }

                autoGeneratedSubtitleIndex++;

                // add the first sentence for the first timestamp
                passage.push_back(result[autoGeneratedSubtitleIndex]);
                
                autoGeneratedParagraphProcessed = true;
            }

            // add to passage for this time
            if (!isAutoGenerated) {

                passage.push_back(line);
            }
        }
    }

    if (foundCount > 0) {

        // this gets filled with all matches, then stored to the results
        video newVideo(file, matches);
        results->addVideo(newVideo);
    }
}

void SearchThread::setToFind(std::string newToFind) {

    toFind = newToFind;
}

void SearchThread::setTermInTitle(std::string newTermInTitle) {

    termInTitle = newTermInTitle;
}

void SearchThread::setFiles(QVector<std::string> newInputFiles) {

    inputFiles = newInputFiles;
}

void SearchThread::setResults(allMatches* newResults) {

    results = newResults;
}

SearchThread::SearchThread() {

}

SearchThread::~SearchThread() {

    delete gOutput;
}
